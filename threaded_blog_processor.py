
# এটা একটা multi-threaded background worker যা blogs টেবিল থেকে pending ব্লগ গুলো প্রসেস করে approved করে দেয়। একই সময় একাধিক thread চালিয়ে faster processing করা হয়


import mysql.connector
import threading
import time

DB_CONFIG = {
    'host': 'localhost',
    'user': 'root',
    'password': '',
    'database': 'blog_db'
}

# Lock to avoid race condition when updating same blog
db_lock = threading.Lock()

def process_blog():
    while True:
        try:
            conn = mysql.connector.connect(**DB_CONFIG)
            cursor = conn.cursor(dictionary=True)

            with db_lock:
                cursor.execute("SELECT * FROM blogs WHERE status = 'pending' LIMIT 1 FOR UPDATE")
                row = cursor.fetchone()

                if row:
                    print(f"[{threading.current_thread().name}] Processing ID: {row['id']}")
                    updated_body = f"Generated by {threading.current_thread().name} for '{row['title']}'"
                    cursor.execute("""
                        UPDATE blogs
                        SET body = %s, status = 'approved'
                        WHERE id = %s
                    """, (updated_body, row['id']))
                    conn.commit()
                else:
                    print(f"[{threading.current_thread().name}] No pending blogs")

            cursor.close()
            conn.close()

        except Exception as e:
            print(f"[{threading.current_thread().name}] Error: {e}")

        time.sleep(10)  # Each thread waits before checking again

# Start multiple threads
def start_threads(num_threads=3):
    for i in range(num_threads):
        t = threading.Thread(target=process_blog, name=f"Worker-{i+1}")
        t.daemon = True  # So they stop when main thread exits
        t.start()

    # Keep main thread alive
    while True:
        time.sleep(60)

if __name__ == "__main__":
    start_threads(num_threads=3)
